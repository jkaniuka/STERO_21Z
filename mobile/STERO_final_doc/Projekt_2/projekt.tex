\chapter{Czêœæ projektowa}


\subsection{Wstêpna konfiguracja g³ównego pliku projektu}  
W pliku \texttt{listener.cpp} subskrybujemy topic \textit{/move\_base\_simple/goal}, aby mieæ bie¿¹c¹ informacjê o lokalizacji punktu docelowego. Istotne jest tak¿e stworzenie obiektu \texttt{tf2\_ros::Buffer}, który wykorzystuje lokalna i globalna mapa kosztów. Podczas tworzenia takiej mapy kluczowe jest to, aby wzajemne transformacje pomiêdzy uk³adem globalnym, uk³adem robota i uk³adem zwi¹zanym z po³o¿eniem sensorów by³y aktualne.  

\subsection{\textit{global\_costmap} z warstw¹ \textit{static}}  
Nastêpnie utworzyliœmy obiekt klasy \texttt{costmap\_2d::Costmap2DROS}, w tym celu niezbêdne by³o tak¿e zdefiniowanie parametrów mapy z warstw¹ static w pliku \texttt{global\_costmap\_params.yaml} oraz odpowiednia konfiguracja wspomnianego pliku w pliku startowym \texttt{tiago\_home.launch}. Dok³adne znaczenie wykorzytsanych parametrów zosta³o wyjaœnione w pliku konfiguracyjnym \textit{.yaml}. Po uruchomieniu wêz³a zosta³a wygenerowana mapa kosztów.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/global_without_inflation}
    \caption{Globalna mapa kosztów z warstw¹ static}
\end{figure}

\subsection{\textit{local\_costmap} z warstwami \textit{static+obstacle}} 
Stworzenie lokalnej mapy kosztów wymaga³o wykonania podobnych czynnoœci jak dla globalnej mapy kosztów. Dodatkowo w pliku konfiguracyjnym \textit{.yaml} zdefinowano warstwê obstacle, która s³u¿y do wykrywania lokalnych przeszkód. Po uruchomieniu wêz³a powsta³a lokalna mapa kosztów.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/local_without_inflation}
    \caption{Lokalna mapa kosztów z warstw¹ static}
\end{figure}

W trakcie testów umieœcilismy przed robotem przeszkodê, lokalna mapa kosztów zosta³a zaktualizowana.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/local_without_inflation_with_obstacle}
    \caption{Lokalna mapa kosztów z warstw¹ static oraz obstacle}
\end{figure}

Dla porównania dokonano te¿ testów z przeszkodami dla globalnej mapy kosztów, tak jak oczekiwaliœmy, globalna mapa nie uwzglêdnia lokalnych przeszkód.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/global_without_inflation_with obstacle}
    \caption{Lokalna mapa kosztów z warstw¹ static}
\end{figure}

\subsection{Dodanie warstwy \textit{infalation} do obydwu map kosztów} 

Po pomyœlnych testach dla statycznych map kosztów przeszliœmy do konfiguracji warstw inflation. Polega³o to g³ównie na dodaniu. w pliku konfiguracyjnym, parametrów: promienia inflacji oraz funkcji kosztu w zale¿noœci od odleg³oœci. Wygl¹d warstwy inflacji przedstawiono na rysunkach poni¿ej.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/global_inflation_layer}
    \caption{Globalna mapa kosztów z warstw¹ static oraz inflation}
\end{figure} 


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/local_inflation_layer}
    \caption{Lokalna mapa kosztów z warstw¹ static oraz inflation}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/local_obstacle_detected_with_lidar}
    \caption{Lokalna mapa kosztów z warstw¹ static, inflation oraz obstacle}
\end{figure}


\subsection{\textit{global\_planner}}
W celu wyznaczenia trasy do zadanego punktu zaimplementowano obs³ugê globalnego plannera przy u¿yciu klasy 
\texttt{global\_planner::GlobalPlanner}. Jego dzia³anie oparte jest o globaln¹ mapê kosztów oraz parametry zdefiniowane w pliku \texttt{global\_planner\_params.yaml}. Œæie¿ka defionowana jest na podstawie algorytmu Dijkstry.Wywo³anie glonalnego planera odbywa siê jednokrotnie przy wyznaczeniu celu ruchu. 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/global_planner}
    \caption{Trasa wyznaczona przez planer globalny - na rysunku zielon¹ lini¹.}
\end{figure}
\subsection{\textit{local\_planner}}  
Wyznaczenie lokalnej trajektorii odbywa siê poprzez algorytmy klasy \texttt{base\_local\_planner::TrajectoryPlannerROS}. Odpowiada ona za generowanie lokalnej œcie¿ki metod¹ DWA, na podstawie lokalnej mapy kosztów(mapa statyczna oraz lokalne przeszkodzy z warstw¹ inflation) oraz za wyznaczenie wektora prêdkoœci. Planer lokalny pracuje w pêtli do czasu, a¿ robot osi¹gnie swój cel, lub wyznaczenie trajektorii nie bêdzie mo¿liwe.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{Projekt_2/plots/local_planner}
    \caption{Trajektoria wyznaczona przez planer lokalny - na rysunku ¿ó³t¹ lini¹.}
\end{figure}

\subsection{\textit{recovery behavior}}

Kiedy robot nie potrafi wygenerowaæ œcie¿ki lub znajdzie siê w po³o¿eniu z którego nie potrafi siê wydostaæ rolê sterowania przejmuje algorytm klasy \texttt{rotate\_recovery::RotateRecovery}. Jego dzia³anie polega na wywo³aniu obrotów robota do czasu, a¿ lokalny planer wyznaczy dostêpn¹ trajektoriê. Dodatkowo wprowadzono czyszczenie lokalnej mapy kosztów, aby zniwelowaæ problem "œladów" po usuniêtych elementach. Poni¿ej widoczna jest grafika przedstawiaj¹ca robota w wy¿ej opisanej sytuacji (strza³ki to wektory prêdkoœci robota z temetu \textit{/odometry}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{Projekt_2/plots/recovery_mode}
    \caption{Recovery behavior.}
\end{figure}

Bardzo istotn¹ kwesti¹ podczas implementacji \texttt{rotate\_recovery::RotateRecovery} jest mapowanie tematów, na którym publikowana jest prêdkoœæ robota. 
\begin{lstlisting}
  <remap from="cmd_vel" to="key_vel"/>
\end{lstlisting}
Mapowanie mo¿na uwzglêdniæ w pliku \textit{.launch} lub w konsoli - ka¿dorazowo przy uruchamianiu wêz³a sterujacego. \texttt{RotateRecovery} jest komponentem \texttt{NavigationStack} i z tego wynika fakt, ¿e wszystkie prêdkoœci s¹ nadawane na temacie \textit{/cmd\_vel} (a TiaGo przyjmuje wiadomoœci typu \texttt{Twist} na temacie \textit{/key\_vel}).

\subsection{Informacja o stanie robota}
W celu informacyjnym oraz w celu u³atwienia debugowania zaimplementowaliœmy komunikaty informuj¹ce o stanie, w którym aktualnie znajduje siê robot. Wykorzystaliœmy w tym celu mechanizm \texttt{ROS\_INFO()}. Komunikaty s¹ nastêpuj¹ce:

\begin{itemize}
  \item \texxtit{Goal passed successfully}
  \item \texxtit{Planning}
  \item \texxtit{In progress}
	\item \texxtit{Recovery behavior}
	\item \texxtit{Finish}
\end{itemize}



